<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />

    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
      integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
      crossorigin="anonymous"
    />

    <link rel="stylesheet" href="../../css/main.css" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>

    <script src="https://unpkg.com/tippy.js@3/dist/tippy.all.min.js"></script>

    <title>Javascript Concurrency</title>
  </head>
  <body>
    <div class="row no-gutters">
      <div class="col-12 p-2 sidebar sidebar-mobile">
        <div class="d-flex justify-content-between">
          <h5 class="m-0">
            <a href="../../index.html">Javascript Concurrency</a>
          </h5>
          <div class="hamburger hamburger--spin">
            <div class="hamburger-box"><div class="hamburger-inner"></div></div>
          </div>
        </div>
      </div>
      <div
        class="col-12 col-sm-12 col-md-12 col-lg-3 col-xl-3 p-2 sidebar sidebar-main"
      >
        <h5><a href="../../index.html">Javascript Concurrency</a></h5>
        <ul class="nav flex-column table-of-contents">
          <li class="nav-item">
            <a class="nav-link" href="../chapter1/chapter1.html">
              Chapter 1: Why JavaScript Concurrency?
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter2/chapter2.html">
              Chapter 2: The JavaScript Execution Model
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link active">
              Chapter 3: Synchronizing with Promises
            </a>
            <ul>
              <li><a href="#promise-terminology">Promise terminology</a></li>
              <li><a href="#promise">Promise</a></li>
              <li><a href="#state">State</a></li>
              <li><a href="#executor">Executor</a></li>
              <li><a href="#resolver">Resolver</a></li>
              <li><a href="#rejector">Rejector</a></li>
              <li><a href="#thenable">Thenable</a></li>
              <li>
                <a href="#resolving-and-rejecting-promises">
                  Resolving and rejecting promises
                </a>
              </li>
              <li><a href="#resolving-promises">Resolving promises</a></li>
              <li><a href="#rejecting-promises">Rejecting promises</a></li>
              <li><a href="#empty-promises">Empty promises</a></li>
              <li><a href="#reacting-to-promises">Reacting to promises</a></li>
              <li>
                <a href="#resolution-job-queues">Resolution job queues</a>
              </li>
              <li><a href="#using-promised-data">Using promised data</a></li>
              <li><a href="#error-callbacks">Error callbacks</a></li>
              <li><a href="#always-reacting">Always reacting</a></li>
              <li>
                <a href="#resolving-other-promises">Resolving other promises</a>
              </li>
              <li><a href="#promise–like-objects">Promise–like objects</a></li>
              <li>
                <a href="#building-callback-chains">Building callback chains</a>
              </li>
              <li>
                <a href="#promises-only-change-state-once">
                  Promises only change state once
                </a>
              </li>
              <li><a href="#immutable-promises">Immutable promises</a></li>
              <li>
                <a href="#many-then-callbacks-many-promises">
                  Many then callbacks, many promises
                </a>
              </li>
              <li>
                <a href="#passing-promises-around">Passing promises around</a>
              </li>
              <li>
                <a href="#synchronizing-several-promises">
                  Synchronizing several promises
                </a>
              </li>
              <li><a href="#waiting-on-promises">Waiting on promises</a></li>
              <li><a href="#cancelling-promises">Cancelling promises</a></li>
              <li>
                <a href="#promises-without-executors">
                  Promises without executors
                </a>
              </li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter4/chapter4.html">
              Chapter 4: Lazy Evaluation with Generators
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter5/chapter5.html"
              >Chapter 5: Working with Workers</a
            >
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter6/chapter6.html">
              Chapter 6: Practical Parallelism
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter7/chapter7.html">
              Chapter 7: Abstracting Concurrency
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter8/chapter8.html">
              Chapter 8: Evented IO with NodeJS
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter9/chapter9.html">
              Chapter 9: Advanced NodeJS Concurrency
            </a>
          </li>
        </ul>
      </div>
      <div
        class="col-12 col-sm-12 col-md-12 col-lg-9 offset-lg-3 col-xl-9 offset-xl-3 main-content"
      >
        <div class="container">
          <h4>Chapter 3: Synchronizing with Promises</h4>
          <p>
            Implementations of promises have existed for many years inside
            JavaScript libraries. It all started with the Promises/A+
            specification. Libraries implemented their own variations of this
            specification, and it wasn't until recently (ES6 to be exact) that
            the Promise specification made it into the JavaScript language. They
            do what the chapter title suggests—help us apply the
            <span class="term" data-term="synchronize">
              synchronization principle.
            </span>
          </p>
          <p>
            In this chapter, we'll start of with a gentle introduction to the
            various terms used in promise-speak so that the remainder of the
            chapter will be a little easier to follow. Then, well go through the
            various ways that promises are used to resolve future values and
            make our lives easier when we deal with concurrency. Ready?
          </p>

          <div id="promise-terminology">
            <h5>Promise terminology</h5>
            <p>
              Before we dive right into the code examples, let's take a minute
              to make sure we have a firm grasp on the terminology surrounding
              promises. There are promise instances, but then there are also
              various states and actions to consider. The sections that follow
              will make much more sense if we can nail down the promise lexicon.
              These explanations are short and sweet, so if you've already used
              promises, you can quickly gloss over these definitions to sanity
              check your knowledge.
            </p>
          </div>

          <div id="promise">
            <h5>Promise</h5>
            <p>
              As the name suggests, a promise is, well, a promise. Think of a
              promise as a proxy for a value that doesn't exist yet. The promise
              let's us write better concurrent code because we know that the
              value will be there at some point, and we don't have to write lots
              of state-checking boilerplate code.
            </p>
          </div>

          <div id="state">
            <h5>State</h5>
            <p>Promises are always in one of three states:</p>
            <ul>
              <li>
                <strong>Pending:</strong> This is the first state of a promise
                after it's been created. It remains in a pending state until
                it's fulfilled or rejected.
              </li>
              <li>
                <strong>Fulfilled:</strong> The promise value has been resolved
                and is available to the <em>then()</em> callback function.
              </li>
              <li>
                <strong>Rejected:</strong> Something went wrong trying to
                resolve the promised value. There will be no data today.
              </li>
            </ul>
            <p>
              An interesting property of promise states is that they only
              transition once. They either go from pending to fulfilled or from
              pending to rejected. And once they make this state transition,
              they're stuck in this state for the rest of their existence.
            </p>
          </div>

          <div id="executor">
            <h5>Executor</h5>
            <p>
              The executor function is responsible for somehow resolving the
              value that the caller is waiting for. This function is called
              immediately after the promise is created. It takes two arguments:
              a resolver function and a rejector function.
            </p>
          </div>

          <div id="resolver">
            <h5>Resolver</h5>
            <p>
              The resolver is a function that's passed to the executor function
              as an argument. Actually, this is quite handy because we can then
              pass the resolver function to another function, and so on. It
              doesn't matter where the resolver function is called from, but
              when it's called, the promise moves into a fulfilled state. This
              change in state will trigger any <em>then()</em> callbacks—we'll
              see what these are shortly.
            </p>
          </div>

          <div id="rejector">
            <h5>Rejector</h5>
            <p>
              It's the second argument passed to the executor function, which
              can be called from anywhere. When it's called, it changes the
              state of the promise from pending to rejected. This state change
              will call the error callback function, if any, passed to
              <em>then()</em> or <em>catch()</em>.
            </p>
          </div>

          <div id="thenable">
            <h5>Thenable</h5>
            <p>
              An object is thenable if it has a <em>then()</em> method that
              accepts a fulfillment callback and a rejection callback as
              arguments. In other words, a promise is thenable. But there are
              cases where we might want to implement specialized resolution
              semantics.
            </p>
          </div>

          <div id="resolving-and-rejecting-promises">
            <h5>Resolving and rejecting promises</h5>
            <p>
              If the preceding section just introduced several new terms that
              sounded confusing, then don't worry. We'll see what all these
              promise terms look like in practice, starting with this section.
              Here, we'll perform some straightforward promise resolving and
              rejecting.
            </p>
          </div>

          <div id="resolving-promises">
            <h5>Resolving promises</h5>
            <p>
              The <span class="term" data-term="resolver">resolver</span> is a
              function that, as the name implies, resolves a promise for us.
              It's not the only way to resolve a promise—we'll explore more
              advanced techniques later on in the chapter. But this method is,
              by far, the most common. It's passed into the
              <span class="term" data-term="executor">executor function</span>
              as the first argument. This means that the executor can resolve
              the promise directly by simply calling the resolver. But this
              wouldn't provide us with much utility, would it?
            </p>
            <p>
              The common case to a greater extent is for the promise
              <span class="term" data-term="executor">executor function</span>
              to set up the asynchronous actions that are about to take
              place—things such as making network calls. Then, in the callback
              functions for these asynchronous actions, we can resolve the
              promise. It's a little counterintuitive at first, passing a
              resolve function around in our code, but it'll make more sense
              once we start using them.
            </p>
            <p>
              A
              <span class="term" data-term="resolver">resolver function</span>
              is an opaque function that's bound to a promise. It can only
              resolve a promise once. We can call the resolver as many times as
              we please, but only the first call will change the state of the
              promise. Now, let's take a look at some promise code. Here, we'll
              resolve a promise, which causes the <em>then()</em> fulfillment
              callback function to be called:
            </p>
            <div class="snippet1">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              As we can see, the <em>fulfilled()</em> function is called when
              the
              <span class="term" data-term="resolver">resolver function</span>
              is called. The
              <span class="term" data-term="executor">executor</span> doesn't
              actually call the resolver. Rather, it passes the resolver
              function to another asynchronous function—<em>setTimeout()</em>.
              The executor function itself isn't the asynchronous code that
              we're trying to wrangle. The executor can be thought of as a sort
              of coordinator, orchestrating asynchronous actions to determine
              when to resolve the promise.
            </p>
            <p>
              The preceding example didn't resolve any values. This is a valid
              use cases when the caller of some action needs acknowledgement
              that it either succeeded or failed. Instead, let's try resolving a
              value this time, as follows:
            </p>
            <div class="snippet2">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              We can see that this code is very similar to the preceding
              example. The difference is that our
              <span class="term" data-term="resolver">resolver function</span>
              is actually called within the closure of the callback function
              that's passed to <em>setTimeout()</em>. This is because we're
              resolving a string value. There's also an argument that's passed
              to our <em>fulfilled()</em> function, which is the resolved value.
            </p>
          </div>

          <div id="rejecting-promises">
            <h5>Rejecting promises</h5>
            <p>
              The promise
              <span class="term" data-term="executor">executor function</span>
              doesn't always go as planned, and when this happens, we need to
              reject the promise. This is the other possible state transition
              from pending. Instead of moving into a fulfilled state, the
              promise moves into a rejected state. This causes a different
              callback to execute, separate from the fulfillment callback.
              Thankfully, the mechanics of rejecting promises is very similar to
              resolving them. Let's take a look at how this is done:
            </p>
            <div class="snippet3">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              This code looks very familiar to the resolution code that we
              looked at in the preceding section. We set a timeout, and instead
              of resolving the function, we rejected it. This is done using the
              <span class="term" data-term="rejector">rejector function</span>
              and is passed into the
              <span class="term" data-term="executor">executor</span> as the
              second argument.
            </p>
            <p>
              We use the <em>catch()</em> method instead of the
              <em>then()</em> method to setup our rejection callback function.
              The rejection callback in this example simply logs the reason for
              the failure as an error. It's always important to provide this
              value. When we resolve promises, a value is common, although not
              strictly necessary. With rejections, on the other hand, there
              isn't a viable case for not providing the reason for the rejection
              even if the callback is only logging the error.
            </p>
            <p>
              Let's look at another example, one that catches exceptions in the
              <span class="term" data-term="executor">executor</span>, and
              provides the rejected callbacks with a more meaningful
              interpretation of the failure:
            </p>
            <div class="snippet4">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              What's interesting about the first promise in the previous example
              is that it does change state, even though we're not explicitly
              changing the state of the promise using <em>resolve()</em> or
              <em>reject()</em>. However, it's important for the promise to
              eventually change state; we'll explore this topic in the next
              section.
            </p>
          </div>

          <div id="empty-promises">
            <h5>Empty promises</h5>
            <p>
              Despite the fact that the
              <span class="term" data-term="executor">executor function</span>
              passes a
              <span class="term" data-term="resolver">resolver function</span>
              and a
              <span class="term" data-term="rejector">rejector function</span>,
              there's never any guarantee that the promise will change state. In
              this scenario, the promise simply hangs, and neither the resolved
              callback nor the rejected callback is triggered. This may not seem
              like a problem, and in fact, with simple promises, it's easy to
              diagnose and fix these unresponsive promises. However, as we get
              into more elaborate scenarios later in the chapter, a promise can
              be resolved as a result of several other promises resolving. If
              one of these promises doesn't resolve or reject, then the whole
              flow falls apart. This scenario is very time-consuming to debug.
              Let's now look at an executor function that causes a promise to
              hang:
            </p>
            <div class="snippet5">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              But what if there was a safer way to deal with this uncertainty?
              An
              <span class="term" data-term="executor">executor function</span>
              with the potential to hang indefinitely without resolving or
              rejecting is hardly something we want in our code. Let's look at
              implementing an executor wrapper function that acts as a safety
              net by rejecting promises that take too long to resolve. This
              would take the mystery out of diagnosing complex promise
              scenarios:
            </p>
            <div class="snippet6">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
          </div>

          <div id="reacting-to-promises">
            <h5>Reacting to promises</h5>
            <p>
              Now that we have a better understanding of the mechanics of
              executing promises, this section will take a closer look at using
              promises to solve particular problems. Typically, this means
              reacting with some purpose in mind when the promise is fulfilled
              or rejected.
            </p>
            <p>
              We'll start off by looking at the job queues inside the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >, and what these mean for our resolution callback functions.
              We'll then look at making use of the promised data, dealing with
              errors, creating better abstractions for reacting to promises, and
              <span class="term" data-term="thenable">thenables</span>. Let's
              get going.
            </p>
          </div>

          <div id="resolution-job-queues">
            <h5>Resolution job queues</h5>
            <p>
              The concept of the JavaScript job queue was introduced in
              <a href="../chapter2/chapter2.html"
                >Chapter 2, The JavaScript Execution Model</a
              >. Its main responsibility is to initiate new execution context
              stacks. This is the main job queue. However, there's another
              queue, which is dedicated to the callbacks executed by promises.
              This means that the algorithm responsible for selecting the next
              job to run can select from either of the queues if they're both
              populated.
            </p>
            <p>
              Promises have concurrency semantics built into them, and with good
              reason. If a promise is used to ensure that a value is eventually
              resolved, it makes sense to give high priority to the code that
              reacts to it. Otherwise, when the value arrives, the code that
              processes it might have to wait in a longer line behind other
              jobs.
            </p>
            <p>
              <em>
                The same semantics are followed with rejected callbacks too.
              </em>
            </p>
            <p>
              Let's write some code that demonstrates these concurrency
              semantics:
            </p>
            <div class="snippet7">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
          </div>

          <div id="using-promised-data">
            <h5>Using promised data</h5>
            <p>
              So far, we've seen a few examples in this chapter where a
              <span class="term" data-term="resolver">resolver function</span>
              resolves a promise with a value. The value that's passed to this
              function is the value that's ultimately passed to the fulfilled
              callback function. The idea is for the
              <span class="term" data-term="executor">executor</span> to set up
              any asynchronous action, such as <em>setTimeout()</em>, which
              would later call the resolver with the value. But in these
              examples, the caller isn't actually waiting on any values; we
              merely use <em>setTimeout()</em> as an example asynchronous
              action. Let's look at a case where we don't actually have a value,
              and an asynchronous network request needs to go get it:
            </p>
            <div class="snippet8">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              With functions like <em>get()</em>, not only do they consistently
              return a synchronization primitive like a promise, but they also
              encapsulate some nasty asynchronous details. Dealing with
              XMLHttpRequest objects all over the place in our code isn't
              pleasant. We've also simplified various modes with which the
              response may come back. Instead of always having to create
              handlers for the load, error, and abort events, we only have one
              interface to worry about—the promise. This is what the
              <span class="term" data-term="synchronize">
                synchronize concurrency principle
              </span>
              is all about.
            </p>
          </div>

          <div id="error-callbacks">
            <h5>Error callbacks</h5>
            <p>
              There are two ways to react to rejected promises. Put differently,
              supplying error callbacks. The first approach is to use the
              <em>catch()</em> method, which takes a single callback function.
              The alternative is to pass in the rejected callback function as
              the second argument to <em>then()</em>.
            </p>
            <p>
              The <em>then()</em> approach that is used to supply rejected
              callback functions is superior in a couple of scenarios, and it
              should probably be used instead of <em>catch()</em>. The first
              scenario is writing our code so that promises and
              <span class="term" data-term="thenable">thenable</span> objects
              are interchangeable. The <em>catch()</em> method isn't necessarily
              part of a thenable. The second scenario is when we build callback
              chains, which we will explore later on in this chapter. Let's look
              at some code that compares the two approaches for providing
              rejected callback functions to promises:
            </p>
            <div class="snippet9">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              We can see here that both approaches are actually very similar.
              There's no real advantage to one over the other in terms of code
              aesthetics. However, there's an advantage to the
              <em>then()</em> approach when it comes to using
              <span class="term" data-term="thenable">thenables</span>, which
              we'll see shortly. But, since we're not actually using the promise
              instance in any way, other than to add the callbacks, there's
              really no need to worry about <em>catch()</em> versus
              <em>then()</em> for registering error callbacks.
            </p>
          </div>

          <div id="always-reacting">
            <h5>Always reacting</h5>
            <p>
              Promises always end up in either a fulfilled state or a rejected
              state. We generally have distinct callback functions for each of
              these states. However, there's a strong possibility that we'll
              want to perform some of the same actions for both states. For
              example, if a component that uses a promise changes state while
              the promise is pending, we'll want to make sure that the state is
              cleaned up once the promise is resolved or rejected.
            </p>
            <p>
              We could write our code in such a way that the callbacks for
              fulfilled and rejected states each perform these actions
              themselves, or that they can each call some common function that
              does the cleanup.
            </p>
            <p>
              Wouldn't it make more sense to assign the cleanup responsibility
              to the promise, instead of assigning it to the individual
              outcomes? This way, the callback function that runs when the
              promise is resolved is focused on what it needs to do with the
              value, and the rejection callback is focused on dealing with the
              error. Let's see if we can write some code that extends promises
              with an <em>always()</em> method:
            </p>
            <div class="snippet10">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              <em>
                Note that the order is important here. If we called
                <em>always()</em> before <em>then()</em>, then the function
                would still always run, but it would run before the callbacks
                provided to <em>then()</em>. We could actually call
                <em>always()</em> before and after <em>then()</em> to always run
                code before the fulfilled or rejected callbacks, and after.
              </em>
            </p>
          </div>

          <div id="resolving-other-promises">
            <h5>Resolving other promises</h5>
            <p>
              Most of the promises that we've seen so far in this chapter have
              either been resolved directly by the
              <span class="term" data-term="executor">executor function</span>
              or as the result of calling the
              <span class="term" data-term="resolver">resolver</span> from an
              asynchronous action, when the value was ready to resolve. Passing
              the resolver function around like this is actually quite flexible.
              For example, the executor doesn't even have to perform any work
              except for storing the resolver function somewhere for it to be
              called later on to resolve the promise.
            </p>
            <p>
              This can be especially useful when we find ourselves in more
              complex synchronization scenarios that require multiple values,
              which have been promised to callers. If we have the
              <span class="term" data-term="resolver">resolver function</span>,
              we can resolve the promise. Let's take a look at code that stores
              the resolver function of several promises so that each promise can
              be resolved later on:
            </p>
            <div class="snippet11">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              As this example makes clear, we don't have to resolve anything
              within the
              <span class="term" data-term="executor">executor function</span>
              itself. In fact, we don't even need to explicitly reference
              promise instances after they've been created and set up with
              executors and fulfillment functions. The
              <span class="term" data-term="resolver">resolver function</span>
              has been stored somewhere, and it holds a reference to the
              promise.
            </p>
          </div>

          <div id="promise–like-objects">
            <h5>Promise–like objects</h5>
            <p>
              The Promise class is a primitive JavaScript type. However, we
              don't always need to create new promise instances to implement the
              same behavior for synchronizing actions. There's a static
              <em>Promise.resolve()</em> method that we can use to resolve such
              objects. Let's see how this method is used:
            </p>
            <div class="snippet12">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
          </div>

          <div id="building-callback-chains">
            <h5>Building callback chains</h5>
            <p>
              Each promise method that we examined so far in this chapter
              returns promises. This allows us to call these methods again on
              the return value, resulting in a chain of
              <em>then().then()</em> calls, and so forth. One challenging aspect
              of chaining promise calls together is that the instances returned
              by promise methods are new instances. That is, there's a degree of
              immutability to the promises that we'll explore in this section.
            </p>
            <p>
              As our application gets larger, the concurrency challenges grow
              with it. This means that we need to think of better ways to
              leverage synchronization primitives, such as promises. Just as any
              other primitive value in JavaScript, we can pass them around from
              function to function. We have to treat promises in the same
              way—passing them around, and building upon the chain of callback
              functions.
            </p>
          </div>

          <div id="promises-only-change-state-once">
            <h5>Promises only change state once</h5>
            <p>
              Promises are born into a pending state, and they die in either a
              resolved or rejected state. Once a promise has transitioned into
              one of these states, they're stuck in this state. This has two
              interesting side-effects.
            </p>
            <p>
              First, multiple attempts to resolve or reject a promise are
              ignored. In other words,
              <span class="term" data-term="resolver">resolvers</span> and
              <span class="term" data-term="rejector">rejectors</span> are
              idempotent—only the first call has any effect on the promise.
              Let's see how this looks code-wise:
            </p>
            <div class="snippet13">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              The other implication of promises changing state only once is that
              the promise could actually resolve before a fulfillment or
              rejection callback is added. Race conditions, such as this one,
              are the harsh reality of concurrent programming. Typically, the
              callback function is added to the promise at the time of creation.
              Since JavaScript is run-to-completion, the job queue that
              processes promise resolution callbacks isn't serviced until the
              callback is added. But, what if the promise resolves immediately
              in the executor? What if the callback is added to the promise in
              another JavaScript execution context? Let's see if we can better
              illustrate these ideas with some code:
            </p>
            <div class="snippet14">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              This code illustrates a very important property of promises. It
              doesn't matter when our fulfillment callbacks are added to the
              promise, whether it's in a pending state, or a fulfilled state,
              the code that uses the promise doesn't change. On the face of it,
              this may not seem like a big deal. But this type of race condition
              checking would require more concurrency code for us to maintain
              ourselves. Instead, the Promise primitive handles this for us, and
              we can start treating asynchronous values as primitive types.
            </p>
          </div>

          <div id="immutable-promises">
            <h5>Immutable promises</h5>
            <p>
              Promises aren't truly immutable. They change state, and the
              <em>then()</em> method adds callback functions to the promise.
              However, there are some immutable traits of promises that are
              worth discussing here, as they impact our promise code in certain
              situations.
            </p>
            <p>
              Technically speaking, the <em>then()</em> method doesn't actually
              mutate the promise object. It creates what's called a promise
              capability, which is an internal JavaScript record that references
              the promise, and the functions that we add. So, it's not a real
              reference in the JavaScript sense of the term.
            </p>
            <p>
              The <em>then()</em> method does not return the same instance it
              was called with as the context. Instead, <em>then()</em> creates a
              new promise instance and returns that. Let's take a look at some
              code to examine more closely what happens when we chain together
              promises using <em>then()</em>:
            </p>
            <div class="snippet15">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              We can clearly see that the two promise instances created in this
              example are separate promise objects. Something else that's worth
              pointing out is that the second promise is bound to the first
              one—it resolves when the first promise resolves. However, we can
              see that the value isn't passed to the second promise. We'll
              address this problem in the following section.
            </p>
          </div>

          <div id="many-then-callbacks-many-promises">
            <h5>Many then callbacks, many promises</h5>
            <p>
              As we saw in the preceding section, promises created with
              <em>then()</em> are bound to their creator. That is, when the
              first promise is resolved, the promise that's bound it it also
              resolves, and so on. However, we noticed a slight problem as well.
              The resolved value doesn't make it past the first callback
              function. The reason our first callback gets the value as an
              argument is because this happens transparently within the promise
              mechanism. Let's take a look at another promise chain example.
              This time, we'll explicitly return the values from our callback
              functions:
            </p>
            <div class="snippet16">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              This looks promising. Now we can see that the resolved value makes
              its way through the promise chain. There's a catch—the rejection
              isn't cumulative. Instead, only the first promise in the chain is
              actually rejected. The remaining promises are simply resolved, not
              rejected. This means that the last <em>catch()</em> callback will
              never run.
            </p>
            <p>
              When we chain together promises in this fashion, our fulfillment
              callback functions need to be able to handle error conditions. For
              example, the value that's resolved could have an error property,
              which could be checked for specifics.
            </p>
          </div>

          <div id="passing-promises-around">
            <h5>Passing promises around</h5>
            <p>
              In this section, we'll extend the idea of treating promises as
              primitive values. Something we often do with primitive values is
              pass them to functions as arguments, and return them from
              functions. The key difference between a promise and other
              primitives is how we use them. Other values exist now, whereas
              promised values will exist eventually. Therefore, we need to
              define some course of action via a callback function to take place
              when the value does arrive.
            </p>
            <p>
              What's nice about promises is that the interface used to supply
              these callback functions is small and consistent. We don't need to
              invent synchronization mechanisms on the fly when we can couple
              the value with the code that will act upon it. These units can
              move around our application just like any other value, and the
              concurrency semantics are unobtrusive.
            </p>
            <p>
              By the end of this function call stack, we have a promise object
              that's reflective of several promises resolving. The whole
              resolution chain is kicked off by the first promise resolving.
              What's more important than the mechanics of how the value
              traverses the chain of promises is the idea that all of these
              functions are free to use this promised value without affecting
              other functions.
            </p>
            <p>
              There are two concurrency principles at play here. First, we will
              <span class="term" data-term="conserve">conserve</span> by
              performing an asynchronous action to get the value only once; each
              of the callback functions are free to use this resolved value.
              Second, we're doing a good job of abstracting our
              <span class="term" data-term="synchronize">synchronization</span>
              mechanisms. In other words, the code doesn't feel like it's
              burdened with boilerplate concurrency code. Let's see what code
              that passes promises around actually looks like:
            </p>
            <div class="snippet17">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              The key functions here are our update
              functions—<em>updateFirstName()</em>, <em>updateLastName()</em>,
              and <em>updateAge()</em>. They're very flexible and accept a
              promise or value resolved by a promise. If any of these functions
              get a promise as an argument, they return a new promise by adding
              a <em>then()</em> callback function. Note that it's adding the
              same function. <em>updateFirstName()</em> will add
              <em>updateFirstName()</em> as the callback. When the callback
              fires, it'll be with the plain object that's used to update the UI
              this time. So the promise check fails, and we can proceed to
              update the UI.
            </p>
            <p>
              The promise checking takes all of three lines per function, which
              is not exactly obtrusive. The end result is the flexible code
              that's easy to read. Ordering doesn't matter; we could have
              composed our <em>update()</em> function in a different order, and
              the UI components would all be updated in the same way. We can
              pass the plain object directly to <em>update()</em> and everything
              will work the same. Concurrent code that doesn't look like
              concurrent code is our big win here.
            </p>
          </div>

          <div id="synchronizing-several-promises">
            <h5>Synchronizing several promises</h5>
            <p>
              Until this point in the chapter, we've looked at single promise
              instances that resolve a value, trigger callbacks, and possibly
              cause other promises to resolve. In this section, we'll look at a
              couple of static Promise methods that help us in scenarios where
              we need to synchronize the resolution of several promise values.
            </p>
            <p>
              First, we'll address the common case where a component that we
              develop requires synchronous access to several asynchronous
              resources. Then, we'll look at the less common scenario where
              asynchronous actions become irrelevant before they're resolved due
              to events that have taken place in the UI.
            </p>
          </div>

          <div id="waiting-on-promises">
            <h5>Waiting on promises</h5>
            <p>
              In the case where we are waiting for several promises to resolve,
              perhaps to transform multiple data sources into something
              consumable by a UI component, we can use the
              <em>Promise.all()</em> method. It takes a collection of promise
              instances as input, and returns a new promise instance. This new
              instance is resolved only when all of the input promises are
              resolved.
            </p>
            <p>
              The <em>then()</em> callback that we provide to the new promise,
              created by <em>Promise.all()</em>, is given an array of resolved
              values as input. These values correspond to the input promises in
              terms of index position. This is a very powerful synchronization
              mechanism, one that helps us fulfill the
              <span class="term" data-term="synchronize"
                >synchronize concurrency principle</span
              >
              because it hides all the bookkeeping.
            </p>
            <p>
              Instead of several callbacks that each need to coordinate the
              state of the promises that they're bound to, we have one callback,
              which has all the resolved data that we need. Here's an example
              that shows how to synchronize multiple promises:
            </p>
            <div class="snippet18">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
          </div>

          <div id="cancelling-promises">
            <h5>Cancelling promises</h5>
            <p>
              The XHR requests that we've seen so far in this book have handlers
              for aborted requests. This is because we can manually abort the
              request and prevent any load callbacks from running. A typical
              scenario that requires this functionality is for the user to click
              a cancel button, or navigate to a different part of the
              application, rendering the request redundant.
            </p>
            <p>
              If we were to move up a level on the abstraction ladder to
              promises, the same principle applies. Something could happen while
              the concurrent action is executing that renders the promise
              pointless. The difference between promises and XHR requests, of
              course, is that the former has no <em>abort()</em> method. The
              last thing we want to do is start introducing unnecessary
              cancellation logic in our promise callbacks.
            </p>
            <p>
              This is where the <em>Promise.race()</em> method can help us. As
              the name suggests, the method returns a new promise that's
              resolved by the first of the input promises to resolve. This may
              not sound like much, but implementing the logic of
              <em>Promise.race()</em> isn't easy. It's the
              <span class="term" data-term="synchronize"
                >synchronize principle</span
              >
              in action, hiding concurrency complexities from the application
              code. Let's take a look at how this method can help us deal with
              cancelled promises due to user interactions:
            </p>
            <div class="snippet19">
              <pre><code class="code-block javascript"></code><div class="position-absolute" style="top: 0; right: 0;"><button class="btn btn-primary shadow-none" load>Load</button><button class="btn btn-danger shadow-none" cancel>Cancel</button></div></pre>
            </div>
            <p>
              <em>
                As an exercise, try to imagine a more complex scenario where
                dataPromise is a promise created by <em>Promise.all()</em>. Our
                <em>cancelResolver()</em> function would be able to seamlessly
                cancel many complex asynchronous actions at once.
              </em>
            </p>
          </div>

          <div id="promises-without-executors">
            <h5>Promises without executors</h5>
            <p>
              In this final section, we'll look at the
              <em>Promise.resolve()</em> and <em>Promise.reject()</em> methods.
              We've already seen how <em>Promise.resolve()</em> can resolve
              <span class="term" data-term="thenable">thenable</span> objects
              earlier in the chapter. It can also directly resolve values or
              other promises. These methods come in handy when we implement a
              function that has the potential to be both synchronous and
              asynchronous. This isn't a situation we want to find ourselves in,
              using a function with ambiguous concurrency semantics. For
              example, here's a function that's both, synchronous and
              asynchronous, leading to confusion, and almost certainly to bugs
              later on:
            </p>
            <div class="snippet20">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              We can see that the last call returns a cached value, instead of a
              promise. This makes intuitive sense because we're not promising an
              eventual value, we already have it! The problem is that we're
              exposing an inconsistency to any code that uses our
              <em>getData()</em> function. That is, the code that calls
              <em>getData()</em> needs to handle concurrency semantics. This
              code is not concurrent. Let's change this by introducing
              <em>Promise.resolve()</em>:
            </p>
            <div class="snippet21">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              This is better. Using <em>Promise.resolve()</em> and
              <em>Promise.reject()</em>, any code that uses
              <em>getData()</em> will get concurrency by default, even when the
              data fetching action is synchronous.
            </p>
          </div>
        </div>
      </div>
    </div>

    <script src="./snippets.js"></script>
    <script src="../../js/main.js"></script>
  </body>
</html>
