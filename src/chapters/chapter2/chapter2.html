<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />

    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
      integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
      crossorigin="anonymous"
    />

    <link rel="stylesheet" href="../../css/main.css" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>

    <script src="https://unpkg.com/tippy.js@3/dist/tippy.all.min.js"></script>

    <title>Javascript Concurrency</title>
  </head>
  <body>
    <div class="row no-gutters">
      <div class="col-12 p-2 sidebar sidebar-mobile">
        <div class="d-flex justify-content-between">
          <h5 class="m-0">
            <a href="../../index.html">Javascript Concurrency</a>
          </h5>
          <div class="hamburger hamburger--spin">
            <div class="hamburger-box"><div class="hamburger-inner"></div></div>
          </div>
        </div>
      </div>
      <div
        class="col-12 col-sm-12 col-md-12 col-lg-3 col-xl-3 p-2 sidebar sidebar-main"
      >
        <h5><a href="../../index.html">Javascript Concurrency</a></h5>
        <ul class="nav flex-column table-of-contents">
          <li class="nav-item">
            <a class="nav-link" href="../chapter1/chapter1.html">
              Chapter 1: Why JavaScript Concurrency?
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link active">
              Chapter 2: The JavaScript Execution Model
            </a>
            <ul>
              <li><a href="#everything-is-a-task">Everything is a task</a></li>
              <li><a href="#meet-the-players">Meet the players</a></li>
              <li>
                <a href="#the-execution-environment">
                  The Execution environment
                </a>
              </li>
              <li><a href="#event-loops">Event loops</a></li>
              <li><a href="#task-queues">Task queues</a></li>
              <li><a href="#execution-contexts">Execution contexts</a></li>
              <li>
                <a href="#maintaining-execution-state">
                  Maintaining execution state
                </a>
              </li>
              <li><a href="#job-queues">Job queues</a></li>
              <li>
                <a href="#creating-tasks-using-timers">
                  Creating tasks using timers
                </a>
              </li>
              <li><a href="#using-setTimeout">Using setTimeout()</a></li>
              <li><a href="#using-setInterval">Using setInterval()</a></li>
              <li>
                <a href="#responding-to-dom-events">Responding to DOM events</a>
              </li>
              <li><a href="#event-targets">Event targets</a></li>
              <li>
                <a href="#managing-event-frequency">Managing event frequency</a>
              </li>
              <li>
                <a href="#responding-to-network-events">
                  Responding to network events
                </a>
              </li>
              <li><a href="#making-requests">Making requests</a></li>
              <li>
                <a href="#coordinating-requests">Coordinating requests</a>
              </li>
              <li>
                <a href="#concurrency-challenges-with-this-model ">
                  Concurrency challenges with this model
                </a>
              </li>
              <li>
                <a href="#limited-opportunity-for-parallelism">
                  Limited opportunity for parallelism
                </a>
              </li>
              <li>
                <a href="#synchronization-through-callbacks">
                  Synchronization through callbacks
                </a>
              </li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter3/chapter3.html">
              Chapter 3: Synchronizing with Promises
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter4/chapter4.html">
              Chapter 4: Lazy Evaluation with Generators
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../chapter5/chapter5.html"
              >Chapter 5: Working with Workers</a
            >
          </li>
        </ul>
      </div>
      <div
        class="col-12 col-sm-12 col-md-12 col-lg-9 offset-lg-3 col-xl-9 offset-xl-3 main-content"
      >
        <div class="container">
          <h4>Chapter 2: The JavaScript Execution Model</h4>
          <p>
            The first chapter of this book explored the state of JavaScript
            concurrency. Generally speaking, dealing with concurrency in
            JavaScript applications is anything but a trivial matter. There's a
            lot to think about when writing concurrent JavaScript code, and the
            kind of solutions that we come up with are often unorthodox. There's
            a lot of callbacks, and wading through all of them is enough to
            drive a person insane. We also caught a glimpse of how our pattern
            of writing concurrent JavaScript code has started to change with
            existing concurrency components. Web workers have started to mature,
            and JavaScript language concurrency constructs have only just been
            introduced.
          </p>
          <p>
            The language and the runtime environment only get us partway there.
            We need to think about concurrency at the design level, rather than
            after the fact. Concurrency should be the default. This is easy to
            say and very difficult to do. Throughout this book, we're going to
            explore all that the JavaScript concurrency features have to offer,
            and how we can best use them to our advantage as design tools. But,
            before we do this, we need to go into depth on what's really
            happening when our JavaScript runs. This knowledge is an essential
            input to designing concurrent applications, because we'll know
            exactly what to expect when choosing one concurrency mechanism over
            another.
          </p>
          <p>
            In this chapter, we'll start with the browser environment, by
            looking at all the subsystems that our code touches—such as the
            JavaScript interpreter, the task queue, and the DOM itself. Then
            we'll walk through some code that will shed some light on what's
            really happening behind the scenes to orchestrate our code. We'll
            close the chapter with a discussion on the challenges that we face
            with this model.
          </p>

          <div id="everything-is-a-task">
            <h5>Everything is a task</h5>
            <p>
              When we visit a web page, a whole environment is created for us
              within the browser. This environment has several subsystems that
              enable the webpage we're looking at to look and behave as it
              should according to
              <strong>World Wide Web Consortium (W3C)</strong> specs. Tasks are
              the fundamental abstraction inside a web browser. Anything that
              happens is either a task itself, or a smaller part of a larger
              task.
            </p>
            <p>
              <em>
                If you're reading any of the W3C specifications, the term "user
                agent" is used instead of "web browser". In 99.9% of cases, the
                major browser vendors are what we're reading about.
              </em>
            </p>
            <p>
              In this section, we'll look at the major components of these
              environments, and how task queues and event loops facilitate the
              communication between these components, to realize the overall
              appearance and behavior of the web page.
            </p>
          </div>

          <div id="meet-the-players">
            <h5>Meet the players</h5>
            <p>
              Let's introduce some terminology that will help us throughout the
              various sections in this chapter:
            </p>
            <ul>
              <li>
                <strong>Execution environment:</strong> This container gets
                created whenever a new web page is opened. It's the
                all-encompassing environment, which has everything that our
                JavaScript code will interact with. It also serves as a
                sandbox—our JavaScript code can't reach outside of this
                environment.
              </li>
              <li>
                <strong>JavaScript interpreter:</strong> This is the component
                that's responsible for parsing and executing our JavaScript
                source code. It's the browser's job to augment the interpreter
                with globals, such as window, and XMLHttpRequest.
              </li>
              <li>
                <strong>Task queue:</strong> Tasks are queued whenever something
                needs to happen. An execution environment has at least one of
                these queues, but typically, it has several of them.
              </li>
              <li>
                <strong>Event loop:</strong> An execution environment has a
                single event loop that's responsible for servicing all task
                queues. There's only one event loop, because there's only one
                thread.
              </li>
            </ul>
            <p>
              The task queues are the entry points for anything that happens in
              the browser. For example, one task can be used to execute a script
              by passing it to the JavaScript interpreter, while another task is
              used to render pending DOM changes. Now we'll dig into the parts
              that make up the environment.
            </p>
          </div>

          <div id="the-execution-environment">
            <h5>The Execution environment</h5>
            <p>
              Perhaps the most revealing aspect of the web browser execution
              environment is the relatively minor role played by our JavaScript
              code and the
              <span class="term" data-term="javascriptInterpreter"
                >interpreter</span
              >
              that executes it. Our code is simply a cog in a much larger
              machine. There's certainly a lot going on within these
              environments, because the platform that browsers implement serve
              an enormous purpose. It's not simply a matter of rendering
              elements on the screen, then enhancing these elements with style
              properties. The DOM itself is similar to a micro platform, just as
              networking facilities, file access, security, and so on. All these
              pieces are essential for a functioning web economy of sites, and
              more recently, applications.
            </p>
            <p>
              In a concurrency context, we're mostly interested in the mechanics
              that tie all these platform pieces together. Our application is
              written mainly in JavaScript, and the interpreter knows how to
              parse and run it. But, how does this ultimately translate into
              visual changes on the page? How does the networking component of
              the browser know to make an HTTP request, and how does it invoke
              the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              once the response has arrived?
            </p>
            <p>
              It's the coordination of these moving parts that restricts our
              concurrency options in JavaScript. These restrictions are
              necessary, because without them, programming web applications
              would become too complex.
            </p>
          </div>

          <div id="event-loops">
            <h5>Event loops</h5>
            <p>
              Once an
              <span class="term" data-term="executionEnvironment"
                >execution environment</span
              >
              is in place, the event loop is one of the first components to
              start. Its job is to service one or more
              <span class="term" data-term="taskQueue">task queues</span> in the
              environment. Browser vendors are free to implement queues as they
              see fit, but there has to be at least one queue. Browsers can
              place every task in one queue if they please, and treat every task
              with equal priority. The problem with doing so would mean that if
              the queue is getting backlogged, tasks that must receive priority,
              such as mouse or keyboard events, are stuck in line.
            </p>
            <p>
              In practice, it makes sense to have a handful of queues, if for no
              other reason than to separate tasks by priority. This is all the
              more important because there's only one thread of control—meaning
              only one CPU—that will process these queues.
            </p>
            <p>
              Even though the event loop is started along with the
              <span class="term" data-term="executionEnvironment"
                >execution environment</span
              >, this doesn't mean that there's always tasks for it to consume.
              If there were always tasks to process, there would never be any
              CPU time for the actual application. The event loop will sit and
              wait for more tasks, and the queue with the highest priority gets
              serviced first.
            </p>
          </div>

          <div id="task-queues">
            <h5>Task queues</h5>
            <p>
              The concept of queued tasks is essential to understand how web
              browsers work. The term browser is actually misleading. We used
              them to browse static web pages in an earlier, sparser web. Now,
              large and complex applications run in browsers—it's really more of
              a web platform. The
              <span class="term" data-term="taskQueue">task queues</span> and
              <span class="term" data-term="eventLoop">event loops</span> that
              service them are probably the best design to handle so many moving
              parts.
            </p>
            <p>
              We saw earlier in this chapter that the JavaScript interpreter,
              along with the code that it parses and runs, is really just a
              black box when viewed from the perspective of an
              <span class="term" data-term="executionEnvironment"
                >execution environment</span
              >. In fact, invoking the
              <span class="term" data-term="javascriptInterpreter"
                >interpreter</span
              >
              is itself a task, and is reflective of the run-to-completion
              nature of JavaScript.
            </p>
            <p>
              Any one of the following events—the user clicking an element, a
              script loading in the page, or data from a prior API call arriving
              in the browser—creates a task that invokes the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >. It tells the interpreter to run a specific piece of code, and
              it'll continue to run it until it completes. This is the
              run-to-completion nature of JavaScript. Next, we'll dig into the
              execution contexts created by these tasks.
            </p>
          </div>

          <div id="execution-contexts">
            <h5>Execution contexts</h5>
            <p>
              Now it's time to look at the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              itself—the component that takes over from other browser components
              when events take place and code needs to run. There's always an
              active JavaScript context, and within the interpreter, we'll find
              a stack of contexts. This is similar to many programming languages
              where stacks control the active context.
            </p>
            <p>
              Think of the active context as a snapshot of what's happening
              right now in our JavaScript code. A stack structure is used
              because the active context can change to something else, such as
              when a function is called. When this happens, a new snapshot is
              pushed onto the stack, becoming the active context. When it's done
              running, it's popped from the stack, leaving the next context as
              the active context.
            </p>
            <p>
              In this section, we'll take a look at how the JavaScript
              interpreter handles context switching, and the internal job queue
              that manages the context stack.
            </p>
          </div>

          <div id="maintaining-execution-state">
            <h5>Maintaining execution state</h5>
            <p>
              The stack of contexts within the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              isn't a static structure—it's constantly changing. There's two
              important things that happen throughout the lifetime of this
              stack. First, at the top of the stack, we have the active context.
              This is the code that currently executes as the interpreter moves
              through its instructions.
            </p>
            <p>
              The other important responsibility of the call stack is to
              bookmark the state of an active context when it's deactivated. For
              example, let's say that after a few statements,
              <em>func1()</em> calls <em>func2()</em>. At this point, the
              context is bookmarked to the spot directly after the call to
              <em>func2()</em>. Then, it's replaced with the new active
              context—<em>func2()</em>. When it completes, the process is
              repeated and <em>func1()</em> again becomes the active context.
            </p>
            <p>
              This kind of context switching happens all over our code. For
              example, there's a global context, which is the entry point into
              our code, there's the functions themselves which have their own
              context. There are also more recent additions to the language,
              which have their own contexts, such as modules and generators.
              Next, we'll look at the job queues responsible for creating new
              execution contexts.
            </p>
          </div>

          <div id="job-queues">
            <h5>Job queues</h5>
            <p>
              Jobs queues are similar to the
              <span class="term" data-term="taskQueue">task queues</span> that
              we looked at earlier. The difference is that job queues are
              specific to the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >. That is, they're encapsulated within the interpreter—the
              browser doesn't interact directly with these queues. However, when
              the interpreter is invoked by the browser, in response to a loaded
              script or event callback task for example, new jobs are created by
              the interpreter.
            </p>
            <p>
              The job queues within the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              are actually much more straightforward than the
              <span class="term" data-term="taskQueue">task queues</span> that
              are used to coordinate all the web browser components. There are
              only two essential queues. One is for creating new execution
              context stacks (call stacks). The other is specific to promise
              resolution callback functions.
            </p>
            <p>
              <em>
                We'll go into more depth on how the promise resolution callback
                job works in the next chapter.
              </em>
            </p>
            <p>
              Given the restricted responsibilities of these internal JavaScript
              job queues, one might draw the conclusion that they're
              unnecessary—an act of over engineering. That's not true, because
              while today there's limited responsibilities found in these jobs,
              the job queue design allows for much easier expansion and
              refinement of the language. In particular, the job queue mechanism
              is favorable when considering new concurrency constructs in future
              versions of the language.
            </p>
          </div>

          <div id="creating-tasks-using-timers">
            <h5>Creating tasks using timers</h5>
            <p>
              So far in this chapter, we've had a look at all the inner workers
              of the web browser environment, and where the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              fits in this environment. What does all this have to do with
              applying concurrency principles to our code? With the knowledge of
              what's happening under the hood, we have a greater insight into
              what's happening when a given chunk of our code is run.
              Particularly, we know what's happening relative to other code
              chunks; time ordering is a crucial concurrency property.
            </p>
            <p>
              This being said, let's actually write some code. In this section,
              we'll use timers to explicitly add tasks to the
              <span class="term" data-term="taskQueue">task queue</span>. We'll
              also learn when and where the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              jumps in and starts executing our code.
            </p>
          </div>

          <div id="using-setTimeout">
            <h5>Using setTimeout()</h5>
            <p>
              The <em>setTimeout()</em> function is staple in any JavaScript
              code. It's used to execute code at some point in the future. New
              JavaScript programmers often trip over the
              <em>setTimeout()</em> function because it's a timer. At a set
              point in the future, say 3 seconds from now, a callback function
              will be invoked. When we call <em>setTimeout()</em>, we will get
              the a timer ID in return, which can be cleared later on using
              <em>clearTimeout()</em>. Here's what the basic usage of
              <em>setTimeout()</em> looks like:
            </p>
            <div class="snippet1">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              Here's the part that's misunderstood by JavaScript newcomers; it's
              a best effort timer. The only guarantee we have when using
              <em>setTimeout()</em> is that our callback function will never be
              called sooner than the allotted time that we pass it. So if we
              said call this function in 300 milliseconds, it'll never call it
              in 275 milliseconds. Once the 300 milliseconds have elapsed, a new
              task is queued. If there's nothing waiting in line before this
              task, the callback is run right on time. Even if there are a few
              things in the queue in front of it, the effects are hardly
              noticeable—it appears to run at the correct time.
            </p>
            <p>
              But as we've seen, JavaScript is single threaded and
              run-to-completion. This means that once the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              starts, it doesn't stop until it's finished; even if there's a
              task waiting for a timer event callback. So, it's entirely
              possible that even though we asked the timer to execute the
              callback in 300 milliseconds, it executes it in 500 milliseconds.
              Let's take a look at an example to see how this is possible:
            </p>
            <div class="snippet2">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
          </div>

          <div id="using-setInterval">
            <h5>Using setInterval()</h5>
            <p>
              The cousin of <em>setTimeout()</em> is the
              <em>setInterval()</em> function. As the name suggests, it accepts
              a callback function that's to be called at a regular interval. In
              fact, <em>setInterval()</em> takes the exact same arguments as
              <em>setTimeout()</em>. The only difference is that it will keep
              calling the function every x milliseconds until the timer is
              cleared using <em>clearInterval()</em>.
            </p>
            <p>
              This function is handy when we want to keep calling the same
              function, over and over. For example, if we poll an API endpoint,
              <em>setInterval()</em> is a good candidate solution. However, keep
              in mind that the scheduling of the callbacks is fixed. That is,
              once we call <em>setInterval()</em> with, say, 1000 milliseconds,
              there's no changing that 1000 milliseconds without first clearing
              the timer. For cases where the interval needs to be dynamic, using
              <em>setTimeout()</em> works better. The callback schedules the
              next interval, which allows the interval to be dynamic. For
              example, backing off from polling an API too frequently by
              increasing the interval.
            </p>
            <p>
              In the <em>setTimeout()</em> example that we last looked at, we
              saw how running JavaScript code can mess with the
              <span class="term" data-term="eventLoop">event loop</span>. That
              is, it prevents the event loop from consuming the task that
              invokes the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              with our callback function. This allows us to defer code execution
              till some point in the future, but with no promises of accuracy.
              Let's see what happens when we schedule tasks using
              <em>setInterval()</em>. There's also some blocking JavaScript code
              that runs afterward:
            </p>
            <div class="snippet3">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
          </div>

          <div id="responding-to-dom-events">
            <h5>Responding to DOM events</h5>
            <p>
              In the preceding section, we saw how to schedule JavaScript code
              to run at a later time. This is done explicitly by other
              JavaScript code. Most of the time, our code runs in response to
              user interactions. In this section, we'll look at the common
              interface that's used not only by DOM events, but also by things
              such as network and web worker events. We'll also look at a
              technique for dealing with large volumes of similar events—called
              debouncing.
            </p>
          </div>

          <div id="event-targets">
            <h5>Event targets</h5>
            <p>
              The <em>EventTarget</em> interface is used by many browser
              components, including DOM elements. It's how we dispatch events to
              elements as well as listen to events and respond by executing a
              callback function. It's actually a very straightforward interface
              that's easy to follow. This is crucial since many different types
              of components use this same interface for event management. We'll
              see as we progress through the book.
            </p>
            <p>
              The same
              <span class="term" data-term="taskQueue">task queue</span>
              mechanisms that execute the callback functions for the timers that
              we used in the preceding section are relevant for
              <em>EventTarget</em> events. That is, if an event has taken place,
              a task to invoke the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              with the appropriate callback is queued. The same limitations
              faced with using <em>setTimeout()</em> are imposed here.
            </p>
            <p>
              In addition to attaching listener functions to event targets that
              react to user interaction, we can trigger these events manually,
              as the following code illustrates:
            </p>
            <div class="snippet4">
              <pre><code class="code-block javascript"></code><div class="position-absolute" style="top: 0; right: 0;"><button class="btn btn-secondary shadow-none" time>Time</button></div></pre>
            </div>
            <p>
              It's good practice to name functions that are used in callbacks
              where possible. This way, when our code breaks, it's much easier
              to trace down the problem. It's not impossible with anonymous
              functions, it's just more time consuming. On the other hand, arrow
              functions are more concise and have more binding flexibility.
              Choose your trade-offs wisely.
            </p>
          </div>

          <div id="managing-event-frequency">
            <h5>Managing event frequency</h5>
            <p>
              One challenge with user interaction events is that there can be
              lots of them, in a very short amount of time. For instance, when
              the user moves the mouse around on the screen, hundreds of events
              are dispatched. If we had event targets listening for these
              events, the
              <span class="term" data-term="taskQueue">task queue</span> would
              quickly fill up, and the user experience would bog down.
            </p>
            <p>
              Even when we do have event listeners in place for high frequency
              events, such as mouse moves, we don't necessarily need to respond
              to all of them. For example, if there's 150 mouse move events that
              take place in 1-2 seconds, chances are, we only care about the
              last move—the most recent position of the mouse pointer. That is,
              the
              <span class="term" data-term="javascriptInterpreter"
                >JavaScript interpreter</span
              >
              is being invoked with our event callback code 149 times more than
              it needs to.
            </p>
            <p>
              To deal with these types of event frequency scenarios, we can
              utilize a technique called <em>debouncing</em>. A debounced
              function means that if it's called in succession more than once
              within a given time frame, only the last call is actually used and
              the earlier calls are ignored. Let's walk through an example of
              how we can implement this:
            </p>
            <div class="snippet5">
              <pre><code class="code-block javascript"></code><div class="position-absolute" style="top: .2rem; right: .2rem;"><input type="text" class="form-control" placeholder="Debouncing Input" debounce></div></pre>
            </div>
            <p>
              Using the debounce technique to avoid giving the CPU more work
              than necessary is an example of the
              <span class="term" data-term="conserve">conserve principle</span>
              in action. By ignoring 149 events, we save (conserve) the CPU
              instructions that would otherwise be executed and provide no real
              value. We also save on any kind of memory allocation that would
              otherwise happen in these event handlers.
            </p>
            <p>
              The JavaScript concurrency principles were introduced at the end
              of
              <a href="../chapter1/chapter1.html">
                Chapter 1, Why JavaScript Concurrency?</a
              >, and they'll be pointed out throughout the code examples in the
              remainder of the book.
            </p>
          </div>

          <div id="responding-to-network-events">
            <h5>Responding to network events</h5>
            <p>
              Another critical piece of any front-end application is network
              interactions, fetching data, issuing commands, and so forth. Since
              network communications are an inherently asynchronous activity, we
              have to rely on events—the <em>EventTarget</em> interface to be
              precise.
            </p>
            <p>
              We'll start by looking at the generic mechanism that hooks up our
              callback functions with requests and getting responses from the
              back-end. Then, we'll look at how trying to synchronize several
              network requests creates a seemingly hopeless concurrency
              scenario.
            </p>
          </div>

          <div id="making-requests">
            <h5>Making requests</h5>
            <p>
              To interact with the network, we create a new instance of
              <em>XMLHttpRequest</em>. We then tell it the type of request that
              we want to make—GET versus POST and the request endpoint. These
              request objects also implement the <em>EventTarget</em> interface
              so that we can listen for data arriving from the network. Here's
              an example of what this code looks like:
            </p>
            <div class="snippet6">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              We can see here that there are a number of possible states for
              network requests. The successful path is the server responding
              with the data we need and we're able to parse it as JSON. The
              error state is when something went wrong, maybe the server isn't
              reachable. The final state that we're concerned with here is when
              the request is cancelled or aborted. This means that we no longer
              care about the successful path because something in our
              application changed while the request was in flight. The user
              navigated to another section, for example.
            </p>
            <p>
              While the previous code was easy enough to use and understand,
              it's not always the case. We're looking at a single request and a
              few callbacks. Very seldom do our application components consist
              of a single network request.
            </p>
          </div>

          <div id="coordinating-requests">
            <h5>Coordinating requests</h5>
            <p>
              In the preceding section, we saw what the basic interaction with
              <em>XMLHttpRequest</em> instances looks like for making a network
              request. The challenge surfaces when there are several requests.
              Most of the time, we make multiple network requests so that we
              have the data necessary for rendering a UI component. The
              responses from the backend will all arrive at different times, and
              are likely dependent on one another.
            </p>
            <p>
              Somehow, we need to synchronize the responses of these
              asynchronous network requests. Let's take a look at how we can go
              about doing this using the <em>EventTaget</em> callback functions:
            </p>
            <div class="snippet7">
              <pre><code class="code-block javascript"></code><button class="btn btn-secondary shadow-none run-code-button">Run</button></pre>
            </div>
            <p>
              There's a lot of extra bits to consider when there's more than one
              request. Since they all arrive at different times, we need to
              store the parsed responses in an array, and with the arrival of
              every response, we need to check if we have everything we expect.
              This simplified example doesn't even take into consideration
              failed or cancelled requests. As this code alludes, the callback
              function approach to synchronization is limiting. In the coming
              chapters, we'll learn how to overcome this limitation.
            </p>
          </div>

          <div id="concurrency-challenges-with-this-model">
            <h5>Concurrency challenges with this model</h5>
            <p>
              We'll wrap this chapter up with a discussion on the challenges
              that this execution model poses with JavaScript concurrency. There
              are two fundamental obstacles. The first is the fact that no
              matter what, any JavaScript code that runs will block anything
              else from happening. The second obstacle is trying to synchronize
              asynchronous actions with callback functions, leading to callback
              hell.
            </p>
          </div>

          <div id="limited-opportunity-for-parallelism">
            <h5>Limited opportunity for parallelism</h5>
            <p>
              It used to be that the lack of parallelism in JavaScript wasn't
              really an issue. Nobody missed it because JavaScript was viewed as
              a progressive enhancement tool for HTML pages. This changed when
              the front-end started taking on more responsibilities. These days,
              the majority of the application actually resides in the front-end.
              This allows back-end components to focus on problems that can't be
              solved by JavaScript (from a browser perspective, NodeJS is
              another matter entirely that we'll look at later in the book).
            </p>
            <p>
              For example, mapping and reducing API data sources into some
              representation required by a feature can be implemented in the
              back-end. This means that the frontend JavaScript code just needs
              to query for this endpoint. The problem is that this API endpoint
              is created for some specific UI feature, not as an essential
              supporting pillar of our data model. If we can perform these tasks
              in the front-end, we keep the UI features and the data
              transformations they need, tightly coupled together. This frees up
              the back-end to stay focused on more pressing issues like
              replication and load balancing.
            </p>
            <p>
              We can perform these types of data transformations in the
              front-end, but they wreak havoc on the usability of the interface.
              This is largely due to all the moving parts competing for the same
              compute resource. This model, in other words, makes it impossible
              for us to implement the
              <span class="term" data-term="parallelize">
                parallelize principle
              </span>
              and take advantage of more than one resource. We will overcome
              this web browser limitation with the help of Web workers, covered
              in further chapters.
            </p>
          </div>

          <div id="synchronization-through-callbacks">
            <h5>Synchronization through callbacks</h5>
            <p>
              Synchronization through callbacks is hard to implement and doesn't
              scale well. It's callback hell, which is a term popular among
              JavaScript programmers. Needless to say, endless synchronization
              through callbacks in our code creates problems. We often have to
              create some kind of state tracking mechanism, such as global
              variables. And when problems do arise, a nest of callback
              functions is very time consuming to traverse mentally.
            </p>
            <p>
              Generally speaking, the callback approach to synchronizing
              multiple asynchronous actions requires a lot of overhead. That is,
              the boilerplate code that exists for the sole purpose of dealing
              with asynchronous actions. The
              <span class="term" data-term="synchronize">
                synchronize concurrency principle</span
              >
              is about writing concurrent code that doesn't embed the main goal
              in a maze of synchronization handling logic. Promises help us
              write concurrent code consistently throughout our application by
              lessening the use of callback functions.
            </p>
          </div>
        </div>
      </div>
    </div>

    <script src="./snippets.js"></script>
    <script src="../../js/main.js"></script>
  </body>
</html>
